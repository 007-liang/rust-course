# 指定依赖项
我们的项目可以引用在 `crates.io` 或 `github` 上的依赖包，也可以引用存放在本地文件系统中的依赖包。

大家可能会想，直接从前两个引用即可，为何还提供了本地方式？可以设想下，如果你要有一个正处于开发中的包，然后需要在本地的另一个项目中引用测试，那是将该包先传到网上，然后再引用简单，还是直接从本地路径的方式引用简单呢？答案显然不言而喻。

本章节，我们一起来看看有哪些方式可以指定和引用三方依赖包。

## 指定来自crates.io的依赖包
默认设置下，`Cargo` 就从 [crates.io](https://crates.io) 上下载依赖包，只需要一个包名和版本号即可：
```toml
[dependencies]
time = "0.1.12"
```

字符串 `"0.1.12"` 是一个 [`semver`](https://semver.org) 格式的版本号，符合 `"x.y.z"` 的形式，其中 `x` 被称为主版本(major), `y` 被称为小版本 `minor` ，而 `z` 被称为 补丁 `patch`，可以看出从左到右，版本的影响范围逐步降低，补丁的更新是无关痛痒的，并不会造成 API 的兼容性被破坏。

`"0.1.12"` 中并没有任何额外的符号，在版本语义上，它跟使用了 `^` 的 `"^0.1.12"` 是相同的，都是指定非常具体的版本进行引入。

但是 `^` 能做的更多。

> npm 使用的就是 `semver` 版本号，从 JS 过来的同学应该非常熟悉。


## 使用 `^` 来指定依赖包的版本
与之前的 `"0.1.12"` 不同， `^` 可以指定一个版本号范围，**然后会使用该范围内的最大版本号来引用对应的包**。

只要新的版本号没有修改最左边的非零数字，那该版本号就在允许的版本号范围中。例如 `"^0.1.12"` 最左边的非零数字是 `1`，因此，只要新的版本号是 `"0.1.z"` 就可以落在范围内，而`0.2.0` 显然就没有落在范围内，因此通过 `"^0.1.12"` 引入的依赖包是无法被升级到 `0.2.0` 版本的。

同理，若是 `"^1.0"`，则 `1.1` 在范围中，`2.0` 则不在。 大家思考下，`"^0.0.1"` 与哪些版本兼容？答案是：无，因为它最左边的数字是 `1` ，而该数字已经退无可退，我们又不能修改 `1`，因此没有版本落在范围中。

```shell
^1.2.3  :=  >=1.2.3, <2.0.0
^1.2    :=  >=1.2.0, <2.0.0
^1      :=  >=1.0.0, <2.0.0
^0.2.3  :=  >=0.2.3, <0.3.0
^0.2    :=  >=0.2.0, <0.3.0
^0.0.3  :=  >=0.0.3, <0.0.4
^0.0    :=  >=0.0.0, <0.1.0
^0      :=  >=0.0.0, <1.0.0
```

以上是更多的例子，事实上，这个规则跟 `SemVer` 还有所不同，因为对于 `SemVer` 而言，`0.x.y` 的版本是没有其它版本与其兼容的，而对于 Rust，只要版本号 `0.x.y` 满足 ： `z>=y` 且 `x>0` 的条件，那它就能更新到 `0.x.z` 版本。


